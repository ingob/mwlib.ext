"""
.t PLATYPUS Proposal


This document is only partly written.  Anticipated sections:
.bu     What is PLATYPUS about?
.bu     Frames and Flowables
.bu     Paragraphs, Paragraph Styles and Text
.bu     Document Templates


.h1 Introduction

.h2 What is this document about?

The ReportLab toolkit aims to be a new generation of reporting tool,
with no limits to formatting.  We expect it to grow large, so have
divided it into a number of subpackages with clear layers of
functionality.

The fundamental layer is the pdfgen subpackage.  This
exposes a Canvas object with methods which correspond almost
one-to-one with the page marking operators in the PDF file format.
This means that programmers can write code to do anything they want,
and build up their own layers of reusable code on top.  However, many
common requirements are not met by PDF directly - it does not do
anything to help you wrap paragraphs or move down the page.

PLATYPUS stands for "Page Layout and Typography Using Scripts".  It is
"one layer up" and deals with frames on pages, and "flowable
objects" such as paragraphs, images or tables which can be placed
within them.  Users will be able to generate "stories" containing
paragraphs and other objects, and write "document templates" to
process them, hopefully with very few limitations on the effects
thatcan be achieved.

.h2 Work to date

PLATYPUS was always an envisaged part of the package, but has taken a
long time to get into shape.  Andy Robinson did a first try for the
Open Source conference in July 1999 (in fact, it was needed to make
the presentation slides), but was simply too hideous to release. A
second try was put together in November 1999 and progressively
refined, appearing when PDFgen was renamed to ReportLab.  This made it
possible to produce very basic flowing documents, but lacked many key
features and still wasn't general enough.

In February and March, Gordon McMillan was asked to propose a revised
API which separated the "story" and the "document template", with the
general goal of "making it all data driven".  He delivered a basic
framework in double-quick time.  In the meantime, we all worked on
projects involving tables and text and began to understand the real
requirements in more detail.  One major upshot was that while the
"story" could easily be seen as data, the variety of formatting tasks
we might want to carry out in the "document tamplate" was almost
infinite; as we thought about extending the document template model to
cope, we realised we were defining a new 'meta-language', and that it
would not be a small one.

Robin Becker then had a key insight:  he remarked that if we had to
work in some language to define report templates, he'd prefer it was
Python. We were working a lot with XML parsers at the time and we
quickly ended up with the idea of the Document Template being a 'story
processor' class which raised events you could hook into when changing
pages, templates, paragraphs and so on. This instantly felt like the
right idea:  no limits to what you could do, templates to be written
in Python code, and above all it was simple and small.

There was a lot of work to do on the details, especially splitting
paragraphs.  Robin Becker has just checked a trial implementation into
CVS, and we have used it to create this document.  Our main goals in
May and June are to get feedback on and solidify this API, and to use
it to produce our own documentation.  We therefore invite comment from
the ReportLab and Python community.  The content of this document will
be updated as comments are received, and the formatting will hopefully
get prettier as we learn how to make nice DocTemplates!

Please pay close attention - you will have to live with this for some
time, and this I your chance to make sure it is clean and usable!


.h2 Use Cases

PLATYPUS should facilitate at least the following kinds of applications:
.bu     Text Wrapping:  you are writing code to create a form, but this
        needs a few paragraphs of justified, wrapped text.  You don't
        want to do the wrapping yourself!
.bu     Word-Processor style reports which automatically flow from one
        page to the next, with page headers and footers which can be
        related to the story content (e.g. page numbers, chapter
        headings in titles)
.bu     Database style reports where a large data set is divided into
        groups with group headers and footers, each occupying a rectangular
        region on the page, and which flow from page to page
.bu     Tables and box constructions in which each cell can contain
        flowing text, images and other graphic objects

Specifically, we would like to be able to build a book, or the Python
Library Reference, automatically from source.

PLATYPUS is NOT designed for
.bu     Precision typesetting by hand - if you are hand-editing a document
        and want PDF, use something else (Word, FrameMaker, TeX) and distill
        the output to PDF instead.  ReportLab is about reports, where you
        want to automatically generate the same kind of document many times.

.bu     Mathematical typography.  While people no doubt could create some
        nice equation widgets in our framework, TEX will probably never be
        exceeded in this regard.

.bu     Quick and dirty database reports on Windows machines which go straight
        to a printer - Access, Crystal et al. handle this well already.


.pageBreak 
.h1 Frames and Flowables

There are several concepts in PLATYPUS and we will go a stage at a
time.  We presume familiarity with the use of PDFgen package to create
basic documents.  The stage we will save until last is how to create a
flowing multi-page document from some data source.  The simplest thing
you can do with PLATYPUS is to place a frame on a page, add some
content to it, and tell it to draw.  Let's do this.  Here's some code
which would create a frame and add two paragraphs to it:

.beginPre Code 
    canvas = Canvas('figure1.pdf')

    frame = Frame(
                    2*inch,     # x
                    4*inch,     # y at bottom
                    4*inch,     # width
                    5*inch     # height
                    )
    frame.showBoundary = 1  # helps us see what's going on

    bodyStyle = ParagraphStyle('Body',
                       fontName='Times-Roman',
                       fontSize=24,
                       leading=28,
                       spaceBefore=6)

    para1 = Paragraph('Spam spam spam spam. ' * 5, bodyStyle)
    para2 = Paragraph('Eggs eggs eggs. ' * 5, bodyStyle)

    mydata = [para1, para2]

    frame.addFromList(mydata,canvas)
    canvas.save()
.endPre

This will result in a page like the one below:

.custom platdemos PlatPropFigure1

Frame has an <i>addFromList</i> method to display content.  It
consumes objects from the front of the list until no more can fit in
its client area or until the list is empty.

Note that there is a certain amount of space between the frame and the
paragraphs within it.  Frames have four 'padding' attributes which can
control this. The attributes can be seen below in the method signature
for initializing a frame.


.beginPre Code
class Frame:
	'''Abstraction for a Frame

                width                    x2,y2
    	+---------------------------------+
    	| l  top padding                r | h
    	| e +-------------------------+ i | e
    	| f |                         | g | i
    	| t |                         | h | g
    	|   |                         | t | h
    	| p |                         |   | t
    	| a |                         | p |
    	| d |                         | a |
    	|   |                         | d |
    	|   +-------------------------+   |
    	|    bottom padding				  |
    	+---------------------------------+
    	(x1,y1)
	'''
	def __init__(self, x1, y1, width,height, leftPadding=6, bottomPadding=6,
			rightPadding=6, topPadding=6, id=None, showBoundary=0):

.endPre

The Padding attributes are formally unnecessary - you could just make
the frame smaller - but are expected to make life easy when working
with frames inside tables.  showBoundary is a debugging tool to draw a
rectangle to show where the frame is.  <i>(Should the padding be zero
by default to reduce surprises?)</i>


.h2 Flowable objects and frame packing

The things which go into frames must conform to the "Flowable"
interface.  This is defined as follows:
.getClassDoc reportlab.platypus.layout Flowable

A conversation takes place between a Flowable object and a
frame involving a number of steps.  First the packer calls
flowable.wrap(availWidth, availheight) to say how much space is
available.  The Flowable should reply with the width and height it
wants.  If this fits, fine; it is told to draw itself in the right
place.  If not, the packer will ask it to split (again with the same
arguments). A dumb flowable will return an empty list indicating that
it cannot split.  A smarter one such as a paragraph or a table might
split itself into a number of separate flowables, the first of which
should fit into the remaining space.

Users may want to implement new Flowable Objects.  For this reason we
will provide some high level base classes - for example, a BaseFigure
class which draws a blank rectangle and a numbered caption underneath;
this could be subclassed and one Draw method added to produce a new
kind of graphic.

A new flowable should implement the methods wrap(), split() and
draw().  Here's a class called XBox which just draws a box of a given
height and width with diagonal lines through it, centred within the
frame, and some text in the centre:

.beginPre Code

    class Box(Flowable):
        def __init__(self, width, height, text):
                """Size is specified up front so we just keep it handy"""
                self.width = width
                self.height = height
                self.text = text

	def wrap(self, availWidth, availHeight):
		"""This will be called by the enclosing frame before objects
		are asked their size, drawn or whatever.  It returns the
		size actually used."""
                # we know how far across to draw it later
                self.dx = 0.5* (availWidth - self.width)
		return (self.width, self.height)

	def split(self, availWidth, availheight):
		"""This will be called by more sophisticated frames when
		wrap fails. Stupid flowables should return []. Clever flowables
		should split themselves and return a list of flowables"""
		return []

	def draw(self):
                self.canv.translate(self.dx, 0)
		self.canv.rect(0, 0, self.width, self.height)
		self.canv.line(0, 0, self.width, self.height)
		self.canv.line(0, self.height, self.width, 0)

		#centre the text
		self.canv.setFont('Times-Roman',12)
		self.canv.drawCentredString(0.5*self.width, 0.5*self.height, self.text)

.endPre

The base Flowable class tried to make drawing easy - it saves and restores the canvas around whatever you do in draw(), so preceding objects cannot affect the way it is drawn, and translates the canvas so that (0,0) is at the lower left of the region the Flowable has requested.

Flowables also have two methods called getSpaceBefore and getSpaceAfter
which try to obtain values for spaceBefore and spaceAfter, first from the object directly
and if that fails then the object's style attribute (if any) is consulted. If all else
fails a default value of zero is assumed.
These attributes do not belong to the object itself and it should not make use of them in any
wrap, split or draw methods.
SpaceBefore will be added before all objects expect the first in a frame; spaceAfter
is added after all objects except the last in a frame.
Paragraph styles make heavy use of spaceBefore and spaceAfter,
getting the information from their associated style objects.

.beginPre Code

    class Dimbo(Flowable):
        def __init__(self, width, height, text):
            """Size is specified up front so we just keep it handy"""
            self.width = width
            self.height = height
            self.text = text
            self.spaceBefore = 72

        def wrap(self,avavailWidth,havailHeight):
            ''' doesn't make use of spaceBefore or spaceAfter'''
            return (self.width, self.height)

    ------

    d = Dimbo(144,144,'A bit of text')
    s = d.getSpaceBefore()   # is 72
    s = d.getSpaceAfter()    # is 0

.endPre

.h2 Flowable objects provided "out of the box"

Here are the things in the package at the moment, or which we plan to add before a release.
.df <b>Paragraph</b> - you know what these are
.df <b>Preformatted</b> - this is for printing code such as the sample in this document.  In Preformatted text there are no font variations and the existing line breaks are used.  A Preformatted object is initialized just like a paragraph, but only uses some of the attributes of the ParagraphStyle.
.df <b>Image</b> - this takes an image file name and an optional width and height.  The latter will be taken from the image file at a scale of 1 point per pixel if no height and width are given.  The image is centred within the frame.
.df <b>Figure</b> - a base class for a rectangular drawing with a caption; people can easily override this to add new ones
.df <b>Spacer</b> - this takes a width and height and serves just to take up some space within the frame.  <i>Note that the width is spurious at the moment.  It is there in the vague hope that one day our packing algorithm starts working in two dimensions - we did not want to be accused of x-ism, even though x-ists we currently are.</i>
.df <b>ActionFlowables</b> - these will do no drawing but will pass 'processing instructions' to the DocTemplate, such as 'Go to the next frame', 'Go to the next page', or 'set the next page template to X'
.df <b>Macro</b> - these would consuist of literal Python code to execute in a certain namespace which gave them access to the canvas, frame and/or document.




.h2 Paragraphs, Paragraph Styles and Text

The most common Flowable objects in most applications will almost certainly be paragraphs, and these are also the most complex we have implemented so far.  This section explains what can be done with Paragraphs.  Moe capabilities may be added in future.


.h3 Initialisation

We have abstracted many of the formatting options out of Paragraph class itself into a separate class called ParagraphStyle.  The idea is that a project will generally define a collection of styles once (in a StyleSheet - see below) and each paragraph will refer to a Style.  This offers consistency benefits for the document, and allows global style changes to be made simply by switching or modifying stylesheets.  It also saves memory - a document with a thousand paragraphs (or, more likely at some point soon, thousands of table cells each of which contains paragraphs) may only need perhaps ten ParagraphStyle objects.

Paragraphs are constructed as follows:

.beginPre Code
from reportlab.platypus.paragraph import Paragraph

# get hold of a stylesheet and style
from reportlab.lib import styles
myStyleSheet = styles.getSampleStyleSheet()
myStyle = myStyleSheet['Normal']   


myPara = Paragraph("Nobody Expects The Spanish Inquisition!", myStyle)
.endPre

Constructing a paragraph is a cheap operation - it just keeps the text internally, and no work is done until a frame tries to wrap and draw it.

Paragraphs also have a third attribute which can be passed in on initialisation, <i>bulletText</i>, which is None by default.  This defines the content for a separate string to be drawn on the first line, typically off to the left.  This can be used for various bullet styles, or for numbering paragraphs according to various conventions.  We'll see bullets flying around later.

.h3 StyleSheets and ParagraphStyle Objects

A <i>StyleSheet</i> (defined in <i>reportlab.lib.styles</i> is a container for a bunch of named styles.  A project will typically define a Python function somewhere to create the standard StyleSheet; one such function is <font name='Courier'>getSampleStyleSheet()</font> in <i>reportlab.lib.styles</i>.
We'll just show an excerpt from this here:
.beginPre Code

def getSampleStyleSheet1():
    """Returns a stylesheet object"""
    stylesheet = StyleSheet1()

    stylesheet.add(ParagraphStyle(name='Normal',
                                  fontName='Times-Roman',
                                  fontSize=10,
                                  leading=12)
                   )

    stylesheet.add(ParagraphStyle(name='BodyText',
                                  parent=stylesheet['Normal'],
                                  spaceBefore=6)
                   )
    stylesheet.add(ParagraphStyle(name='Italic',
                                  parent=stylesheet['BodyText'],
                                  fontName = 'Times-Italic')
                   )

    stylesheet.add(ParagraphStyle(name='Heading1',
                                  parent=stylesheet['Normal'],
                                  fontName = 'Times-Bold',
                                  fontSize=18,
                                  spaceAfter=6),
                   alias='h1')
    # snip - many styles removed
    return stylesheet
.endPre



The stylesheet can be accessed exactly as it it was a dictionary, except that one may use the style name or an alias to find a style:
.beginPre Code
hdg = myStyleSheet['Heading1']
hdg = myStyleSheet['h1']
.endPre


ParagraphStyles have the following attributes which affect the way the associated paragraph is drawn.
.df <font name='Courier'>fontName</font> - one of the standard 14 fonts
.df <font name='Courier'>fontSize</font> - size in points
.df <font name='Courier'>leading</font> - inter-line separation in points.  <i>This should default to 1.2 * font size if not directly specified - not done at present</i>
.df <font name='Courier'>fontSize</font> - size in points
.df <font name='Courier'>textColor</font> - a standard ReportLab color object as defined in <i>reportlab/lib/colors.py</i>
.df <font name='Courier'>firstLine</font> - indentation of first line of text relative to the usable area of the frame.  Thus if a frame has a border and leftPadding of 12 points, and the paragraph style has firstLineIndent of 36 points, the paragraph will be 48 points from the frame border.
.df <font name='Courier'>leftIndent</font> - indentation of lines 2 onwards relative to the left usable edge of the frame
.df <font name='Courier'>rightIndent</font> - indentation of all lines relative to the right usable edge of the frame
.df <font name='Courier'>alignment</font> - one of the four constants TA_LEFT, TA_RIGHT, TA_CENTER and TA_JUSTIFY defined in <i>reportlab.lib.enums</i>
.df <font name='Courier'>bulletFontName</font> - font to be used for the bullet string, if the paragraph has one.
.df <font name='Courier'>bulletFontSize</font> - font to be used for the bullet string, if the paragraph has one.
.df <font name='Courier'>bulletIndent</font> - left indentation of the start of the bullet string, if the paragraph has one.  Note that this needs to be smaller than the <font name='Courier'>firstLine</font> or they will overwrite each other.  
.df <font name='Courier'>spaceBefore</font> - number of points of space to precede the paragraph, except when it is the first item in a frame when there will be no preceding space
.df <font name='Courier'>spaceBefore</font> - number of points of space to follow the paragraph, except when it is the last item in a Frame in which case there will not necessarily be a following space.

Note that <font name='Courier'>spaceBefore</font> and <font name='Courier'>spaceAfter</font> are <i>soft</i> spaces - the Paragraph will ask Platypus for it politely, but may not get it, and the space does not "belong to" the Paragraph itself.  We might generalize these spaces in future to have a degree of stretchiness.

The choice of attributes is based loosely on those in Word, Publisher and other such programs and we feel they are capable of most common tasks.  


.h3 Intra-Paragraph Formatting

To specify changes in font within each paragraph, we use XML tags.  We'll show you a paragraph containing most of the things that can be done:

.df Substrings within paragraphs can be tagged as <b>bold</b>, <i>italic</i> or <u>underlined</u> using the same tags as HTML.  We currently don't implement underlining.  It is also possibly to explicitly choose a font like <font name="Courier">Courier</font> or 
<font size="+1">even</font>
<font size="+2">vary</font>
<font size="+3">the</font>
<font size="+4">font</font>
<font size="+5">size</font>
within a paragraph. Color can be set to <font color="red">red</font>, <font color="green">green</font> or anything else you fancy.  We can have superscripts like x<super>2</super> or subscripts like A<sub>ij</sub>.  Greek letters such as "alpha" (<greek>a</greek>) can either be entered as the equivalent letters inside a "greek" tag, or be entered as HTML entity references "alpha".  Options traders will be disappointed to discover that vega, which they use for volatility, is a star in the constellation of Arcturus and not a 25th letter of the Greek alphabet; they should use "nu" (&nu;) instead.


To create the paragraph above, the input source text was as follows:

.df <font name='Courier'><![CDATA[
Substrings within paragraphs can be tagged as <b>bold</b>, <i>italic</i> or <u>underlined</u> using the same tags as HTML.  We currently don't implement underlining.  It is also possibly to explicitly choose a font like <font name="Courier">Courier</font> or 
<font size="+1">even</font>
<font size="+2">vary</font>
<font size="+3">the</font>
<font size="+4">font</font>
<font size="+5">size</font>
within a paragraph. Color can be set to <font color="red">red</font>, <font color="green">green</font> or anything else you fancy.  We can have superscripts like x<super>2</super> or subscripts like A<sub>ij</sub>.  Greek letters such as "alpha" (<greek>a</greek>) can either be entered as the equivalent letters inside a "greek" tag, or be entered as HTML entity references "alpha".  Options traders will be disappointed to discover that vega, which they use for volatility, is a star in the constellation of Arcturus and not a 25th letter of the Greek alphabet; they should use "nu" (&nu;) instead.
]]></font>


Paragraphs permit two escaping mechanisms which you can use when you really want  to print things which might be mistaken for XML.  The first is to use standard HTML entity references.  Thus <b><![CDATA[&lt;]]></b> produces the character <b>&lt;</b>.  This is the easiest to use for mathematical formulae and code (although no XML processing is done on Preformatted objects, which are the preferred form for printing code).  The second is the standard XML CDATA escaping mechanism.  Anything found between the escape sequences <b>%lt;!CDATA[[</b> and <b>]]&gt;</b> will not be checked for tags; this is thus a very useful mechanism when writing an entire paragraph of XML tags.

The tags which may be used within a paragraph are listed below.  The meanings should be obvious:

.df <![CDATA[<font name="courier" size=14 color="red">...</font>]]>  
This tag can accept any or all of the arguments.  Font names should be lower case equivalents of the PostScript font names.  fg is also permitted as a synonym for color <i>(do we need both?)</i>.  Note that there is no such thing as Bold or Italic for PostScript fonts; one can achieve such effects by choosing such fonts as "Courier_Bold".  Colors are parsed by the function <i>reportlab/lib/colors.stringToColor</i> and support HTML named colors or RGB values like "AABBCC", "0xAABBCC" or "#AABBCC".


.h3 Outermost &lt;para&gt; tag

There can also be an outermost tag around each paragraph which can override the style.  This might be useful if you want the formatting to be totally data-driven (i.e. encoded in the story) rather than dependent on an external style sheet.  This tag can accept arguments corresponding to the properties of ParagraphStyle.  We also provide aliases for some of these attributes which are faster to type, lowercase throughout, or equivalent to HTML:

.df font, fontName, fontname -> fontName, 
.df fontsize, fontSize -> fontsize
.df leading -> leading
.df lindent, leftIndent -> leftIndent
.df rindent, rightIndent -> rightIndent
.df findent, firstLineIndent -> firstLineIndent
.df align -> alignment
.df spaceb -> spaceBefore
.df spacea -> spaceAfter
.df bfont -> bulletFontName
.df bfontsize -> bulletFontSize
.df bindent -> bulletIndent
.df color, fg -> textColor

.pageBreak
.h1 Document Templates

Now for the hard part - how to handle flowing documents.  

The original concept was to make everything "data driven".  A "story" is a "list of flowables".  There would also need to be data structures to define the page templates - things like one or two columns and margins, graphics and text to be drawn in the headers and footers - and maybe even options affecting how the story/stories were directed into the right frames.  This got more and more complex until Robin Becker realized that we were inventing a meta-language for page description, and observed that if wehad to do programming, we would rather do it in Python.  

.h2 Issues to discuss

.h3 Making Page Templates and level of reuse

A PageTemplate defines a number of frames.  Logically, it might also want to decorate itself with static stuff (logos, letterheads), dynamic stuff (the page number), and maybe even information about the current point in the story (the chapter heading, or the first and last words defined on the page, it it was a dictionary).  So some hook is needed to allow custom drawing for a PageTemplate.

Currently we support at least two patterns:

Option 1: make a load of page decoration routines for things like the letterhead.  These take the argument signature myfunc(canvas, doc [, *args, **kwargs]).  These are passed in as the onPage argument when adding PageTemplates to DocTemplates:

.beginPre Code
def decoratePage(canvas, doc):
    canvas.saveState()
    canvas.setFont('Times-Roman', 10)
    canvas.drawCentredString(doc.pagesize[0] / 2, 0.75*inch, 'Page %d' % canvas.getPageNumber())
    canvas.restoreState()

class MyPageTemplate(PageTemplate):
    def __init__(self, id):
        myFrame = Frame(inch, inch, 6*inch, 10*inch, id='normal')
        PageTemplate.__init__(self, id, [myFrame], onPage=decoratePage)

.endPre

Option 2:  Subclass PageTemplate.  So I would design and reuse a class called "MyCompanyAngryLetterFirstPageTemplate", which knew both what frames it had and what else to draw.  If a PageTemplate has a drawPage method, this is called
when the page starts to drw.

.beginPre Code
class MyPageTemplate(PageTemplate):
    def __init__(self, id):
        myFrame = Frame(inch, inch, 6*inch, 10*inch, id='normal')
        PageTemplate.__init__(self, id, [myFrame])  # note lack of onPage

    def drawPage(self, canvas, doc):
        canvas.saveState()
        canvas.setFont('Times-Roman', 10)
        canvas.drawCentredString(doc.pagesize[0] / 2, 0.75*inch, 'Page %d' % canvas.getPageNumber())
        canvas.restoreState()

.endPre
.pageBreak
.h1 API Reference
.getModuleDoc reportlab.pdfgen.canvas


.h1 Appendix A - CVS Revision History
.beginPre Code
$Log: platprop.yml,v $
Revision 1.11  2000/05/24 14:06:34  andy_robinson
Documentation tools working nicely

Revision 1.10  2000/05/24 13:06:00  andy_robinson
CodeGrab utility now working, used to getcanvas reference
for documentation.

Revision 1.9  2000/05/22 09:49:29  andy_robinson
More accurate history a start of document

Revision 1.8  2000/05/18 11:27:18  rgbecker
Minor textual changes

Revision 1.7  2000/05/17 22:18:09  rgbecker
Renamed BasicFrame to Frame

Revision 1.6  2000/05/17 16:30:09  rgbecker
Removal of SimpleFrame

Revision 1.5  2000/05/16 15:40:25  andy_robinson
It now actually says something - checking in before going home

Revision 1.4  2000/05/16 11:18:10  andy_robinson
Added the first of the demo drawings

Revision 1.3  2000/05/15 16:02:41  andy_robinson
More Paragraph Documentation

Revision 1.1  2000/05/15 10:58:54  andy_robinson
Platypus Proposal
.endPre

"""




