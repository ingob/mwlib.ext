.t PLATYPUS Proposal

CVS Revision History
.beginPre Code
$Log: platprop.yml,v $
Revision 1.4  2000/05/16 11:18:10  andy_robinson
Added the first of the demo drawings

Revision 1.3  2000/05/15 16:02:41  andy_robinson
More Paragraph Documentation

Revision 1.1  2000/05/15 10:58:54  andy_robinson
Platypus Proposal
.endPre

This document is only partly written.  Anticipated sections:
.bu     What is PLATYPUS about?
.bu     Frames and Flowables
.bu     Paragraphs, Paragraph Styles and Text
.bu     Document Templates


.h1 Introduction

.h2 What is this document about?

The ReportLab toolkit aims to be a new generation of reporting tool, with no limits to formatting.  We expect it to grow large, so have divided it into a number of subpackages with clear layers of functionality.

The most basic layer for mist users is the pdfgen subpackage.  This exposes a Canvas object with methods which correspond almost one-to-one with the page marking operators in the PDF file format.  This means that programmers can write code to do anything they want, and build up their own layers of reusable code on top.  However, many common requirements are not met by PDF directly - it does not do anything to help you wrap paragraphs or move down the page.  

PLATYPUS stands for "Page Layout and Typography Using Scripts".  It is the "next layer up" and deals with frames on pages, and "flowable objects" such as paragraphs, images or tables which can be placed within them.  Users will be able to generate "stories" containing paragraphs and other objects, and write "document templates" to process them, hopefully with very few limitations on the effects thatcan be achieved.

This was always an envisaged part of the package, but has taken a long time to get right.  The first try was done in July 1999 for the Open Source conference (in fact, it was needed to make the presentation slides), but was simply too hideous to release.  A second try was put together in November 1999 and progressively refined, appearing when PDFgen was renamed to ReportLab.  This made it possible to produce very basic flowing documents, but lacked many key features and still wasn't general enough.  

We have been discussing better implementations for several months and now think we have something promising.  Robin Becker has just checked a trial implementation into CVS, and we have used it to create this document.  Our main goals in May and June are to get feedback on and solidify this API, and to use it to produce our own documentation.  We therefore invite comment from the ReportLab and Python community.   The content of this document will be updated as comments are received, and the formatting will hopefully get prettier as we learn how to make nice DocTemplates!

Please pay close attention - you will have to live with this for some time, and this I your chance to make sure it is clean and usable!


.h2 Use Cases

PLATYPUS should facilitate at least the following kinds of applications:
.bu     Text Wrapping:  you are writing code to create a form, but this needs a few paragraphs of justified, wrapped text.  You don't want to do the wrapping yourself!
.bu    Word-Processor style reports which automatically flow from one page to the next, with page headers and footers which can be related to the story content (e.g. page numbers, chapter headings in titles)
.bu    Database style reports where a large data set is divided into groups with group headers and footers, each occupying a rectangular region on the page, and which flow from page to page
.bu    Tables and box constructions in which each cell can contain flowing text, images and other graphic objects

Specifically, we would like to be able to build a book, or the Python Library Reference, automatically from source.

PLATYPUS is NOT designed for
.bu    Precision typesetting by hand - if you are hand-editing a document and want PDF, use something else (Word, FrameMaker, TeX) and distill the output to PDF instead.  ReportLab is about reports, where you want to automatically generate the same kind of document many times.

.bu   Mathematical typography.  While people no doubt could create some nice equation widgets in our framework, TEX will probably never be exceeded in this regard.

.bu     Quick and dirty database reports on Windows machines which go straight to a printer - Access, Crystal et al. handle this well already.



 
.h1 Frames and Flowables

There are several concepts in PLATYPUS and we will go a stage at a time.  We presume familiarity with the use of PDFgen package to create basic documents.  The stage we will save until last is how to create a flowing multi-page document from some data source.  The simplest thing you can do with PLATYPUS is to
place a frame on a page, add some content to it, and tell it to draw.  Let's
do this.  

.Comment For the rest of this chapter, let's imagine we're using really tiny pieces of paper about a couple of inches high, so the illustrations below are the correct scale.  This is probably easier on the reader than doing scaling in your head.  Remember that the origin of the coordinate system is the bottom left of the page.

.custom platdemos PlatPropFigure1


.h2 Paragraphs, Paragraph Styles and Text

The most common Flowable objects in most applications will almost certainly be paragraphs, and these are also the most complex we have implemented so far.  This section explains what can be done with Paragraphs.


.h3 Initialisation

We have abstracted many of the formatting options out of Paragraph class itself into a separate class called ParagraphStyle.  The idea is that a project will generally define a collection of styles once (in a StyleSheet - see below) and each paragraph will refer to a Style.  This offers consistency benefits for the document, and allows global style changes to be made simply by switching or modifying stylesheets.  It also saves memory - a document with a thousand paragraphs (or, more likely at some point soon, thousands of table cells each of which contains paragraphs) may only need perhaps ten ParagraphStyle objects.

Paragraphs are constructed as follows:

.beginPre Code
from reportlab.platypus.paragraph import Paragraph
myStyle = myStyleSheet['Normal']   # get hold of a style from somewhere
myPara = Paragraph("Nobody Expects The Spanish Inquisition!", myStyle)
.endPre

Constructing a paragraph is a cheap operation - it just keeps the text internally, and no work is done until a frame tries to wrap and draw it.

Paragraphs also have a third attribute which can be passed in on initialisation, <i>bulletText</i>, which is None by default.  This defines the content for a separate string to be drawn on the first line, typically off to the left.  This can be used for various bullet styles, or for numbering paragraphs according to various conventions.  We'll see bullets flying around later.

.h3 StyleSheets and ParagraphStyle Objects

A <i>StyleSheet</i> (defined in <i>reportlab.lib.styles</i> is a container for a bunch of named styles.  A project will typically define a Python function somewhere to create the standard StyleSheet; one such function is <font name='Courier'>getSampleStyleSheet()</font> in <i>reportlab.lib.styles</i>.
We'll just show an excerpt from this here:
.beginPre Code

def getSampleStyleSheet1():
    """Returns a stylesheet object"""
    stylesheet = StyleSheet1()

    stylesheet.add(ParagraphStyle(name='Normal',
                                  fontName='Times-Roman',
                                  fontSize=10,
                                  leading=12)
                   )

    stylesheet.add(ParagraphStyle(name='BodyText',
                                  parent=stylesheet['Normal'],
                                  spaceBefore=6)
                   )
    stylesheet.add(ParagraphStyle(name='Italic',
                                  parent=stylesheet['BodyText'],
                                  fontName = 'Times-Italic')
                   )

    stylesheet.add(ParagraphStyle(name='Heading1',
                                  parent=stylesheet['Normal'],
                                  fontName = 'Times-Bold',
                                  fontSize=18,
                                  spaceAfter=6),
                   alias='h1')
    # snip - many styles removed
    return stylesheet
.endPre



The stylesheet can be accessed exactly as it it was a dictionary, except that one may use the style name or an alias to find a style:
.beginPre Code
hdg = myStyleSheet['Heading1']
hdg = myStyleSheet['h1']
.endPre


ParagraphStyles have the following attributes which affect the way the associated paragraph is drawn.
.df <font name='Courier'>fontName</font> - one of the standard 14 fonts
.df <font name='Courier'>fontSize</font> - size in points
.df <font name='Courier'>leading</font> - inter-line separation in points.  <i>This should default to 1.2 * font size if not directly specified - not done at present</i>
.df <font name='Courier'>fontSize</font> - size in points
.df <font name='Courier'>textColor</font> - a standard ReportLab color object as defined in <i>reportlab/lib/colors.py</i>
.df <font name='Courier'>firstLine</font> - indentation of first line of text relative to the usable area of the frame.  Thus if a frame has a border and leftPadding of 12 points, and the paragraph style has firstLineIndent of 36 points, the paragraph will be 48 points from the frame border.
.df <font name='Courier'>leftIndent</font> - indentation of lines 2 onwards relative to the left usable edge of the frame
.df <font name='Courier'>rightIndent</font> - indentation of all lines relative to the right usable edge of the frame
.df <font name='Courier'>alignment</font> - one of the four constants TA_LEFT, TA_RIGHT, TA_CENTER and TA_JUSTIFY defined in <i>reportlab.lib.enums</i>
.df <font name='Courier'>bulletFontName</font> - font to be used for the bullet string, if the paragraph has one.
.df <font name='Courier'>bulletFontSize</font> - font to be used for the bullet string, if the paragraph has one.
.df <font name='Courier'>bulletIndent</font> - left indentation of the start of the bullet string, if the paragraph has one.  Note that this needs to be smaller than the <font name='Courier'>firstLine</font> or they will overwrite each other.  
.df <font name='Courier'>spaceBefore</font> - number of points of space to precede the paragraph, except when it is the first item in a frame when there will be no preceding space
.df <font name='Courier'>spaceBefore</font> - number of points of space to follow the paragraph, except when it is the last item in a Frame in which case there will not necessarily be a following space.

Note that <font name='Courier'>spaceBefore</font> and <font name='Courier'>spaceAfter</font> are <i>soft</i> spaces - the Paragraph will ask Platypus for it politely, but may not get it, and the space does not "belong to" the Paragraph itself.  We might generalize these spaces in future to have a degree of stretchiness.

The choice of attributes is based loosely on those in Word, Publisher and other such programs and we feel they are capable of most common tasks.  


.h3 Intra-Paragraph Formatting

To specify changes in font within each paragraph, we use XML tags.  We'll show you a paragraph containing most of the things that can be done:

.df Substrings within paragraphs can be tagged as <b>bold</b>, <i>italic</i> or <u>underlined</u> using the same tags as HTML.  We currently don't implement underlining.  It is also possibly to explicitly choose a font like <font name="Courier">Courier</font> or 
<font size="+1">even</font>
<font size="+2">vary</font>
<font size="+3">the</font>
<font size="+4">font</font>
<font size="+5">size</font>
within a paragraph. Color can be set to <font color="red">red</font>, <font color="green">green</font> or anything else you fancy.  We can have superscripts like x<super>2</super> or subscripts like A<sub>ij</sub>.  Greek letters such as "alpha" (<greek>a</greek>) can either be entered as the equivalent letters inside a "greek" tag, or be entered as HTML entity references "alpha".  Options traders will be disappointed to discover that vega, which they use for volatility, is a star in the constellation of Arcturus and not a 25th letter of the Greek alphabet; they should use "nu" (&nu;) instead.


To create the paragraph above, the input source text was as follows:

.df <font name='Courier'><![CDATA[
Substrings within paragraphs can be tagged as <b>bold</b>, <i>italic</i> or <u>underlined</u> using the same tags as HTML.  We currently don't implement underlining.  It is also possibly to explicitly choose a font like <font name="Courier">Courier</font> or 
<font size="+1">even</font>
<font size="+2">vary</font>
<font size="+3">the</font>
<font size="+4">font</font>
<font size="+5">size</font>
within a paragraph. Color can be set to <font color="red">red</font>, <font color="green">green</font> or anything else you fancy.  We can have superscripts like x<super>2</super> or subscripts like A<sub>ij</sub>.  Greek letters such as "alpha" (<greek>a</greek>) can either be entered as the equivalent letters inside a "greek" tag, or be entered as HTML entity references "alpha".  Options traders will be disappointed to discover that vega, which they use for volatility, is a star in the constellation of Arcturus and not a 25th letter of the Greek alphabet; they should use "nu" (&nu;) instead.
]]></font>


Paragraphs permit two escaping mechanisms which you can use when you really want  to print things which might be mistaken for XML.  The first is to use standard HTML entity references.  Thus <b><!CDATA[[&lt;]]></b> produces the character %lt;.  This is the easiest to use for mathematical formulae and code (although no XML processing is done on Preformatted objects, which are the preferred form for printing code).  The second is the standard XML CDATA escaping mechanism.  Anything found between the escape sequences <b>%lt;!CDATA[[</b> and <b>]]&gt;</b> will not be checked for tags; this is thus a very useful mechanism when writing an entire paragraph of XML tags.

The tags which may be used within a paragraph are listed below.  The meanings should be obvious:

.df <![CDATA[<font name="courier" size=14 color="red">...</font>]]>  
This tag can accept any or all of the arguments.  Font names should be lower case equivalents of the PostScript font names.  fg is also permitted as a synonym for color <i>(do we need both?)</i>.  Note that there is no such thing as Bold or Italic for PostScript fonts; one can achieve such effects by choosing such fonts as "Courier_Bold".  Colors are parsed by the function <i>reportlab/lib/colors.stringToColor</i> and support HTML named colors or RGB values like "AABBCC", "0xAABBCC" or "#AABBCC".


.h3 Outermost &lt;para&gt; tag

There can also be an outermost tag around each paragraph which can override the style.  This might be useful if you want the formatting to be totally data-driven (i.e. encoded in the story) rather than dependent on an external style sheet.  This tag can accept arguments corresponding to the properties of ParagraphStyle.  We also provide aliases for some of these attributes which are faster to type, lowercase throughout, or equivalent to HTML:

.df font, fontName, fontname -> fontName, 
.df fontsize, fontSize -> fontsize
.df leading -> leading
.df lindent, leftIndent -> leftIndent
.df rindent, rightIndent -> rightIndent
.df findent, firstLineIndent -> firstLineIndent
.df align -> alignment
.df spaceb -> spaceBefore
.df spacea -> spaceAfter
.df bfont -> bulletFontName
.df bfontsize -> bulletFontSize
.df bindent -> bulletIndent
.df color, fg -> textColor




.h1 Document Templates


.h2 Issues to discuss

.h3 Making Page Templates and level of reuse

A PageTemplate defines a number of frames.  Logically, it might also want to decorate itself with static stuff (logos, letterheads), dynamic stuff (the page number), and maybe even information about the current point in the story (the chapter heading, or the first and last words defined on the page, it it was a dictionary).  So some hook is needed to allow custom drawing for a PageTemplate.

Currently we support at least two patterns:

Option 1: make a load of page decoration routines for things like the letterhead.  These take the argument signature myfunc(canvas, doc [, *args, **kwargs]).  These are passed in as the onPage argument when adding PageTemplates to DocTemplates:

.beginPre Code
def decoratePage(canvas, doc):
    canvas.saveState()
    canvas.setFont('Times-Roman', 10)
    canvas.drawCentredString(doc.pagesize[0] / 2, 0.75*inch, 'Page %d' % canvas.getPageNumber())
    canvas.restoreState()

class MyPageTemplate(PageTemplate):
    def __init__(self, id):
        myFrame = BasicFrame(inch, inch, 6*inch, 10*inch, id='normal')
        PageTemplate.__init__(self, id, [myFrame], onPage=decoratePage)

.endPre

Option 2:  Subclass PageTemplate.  So I would design and reuse a class called "MyCompanyAngryLetterFirstPageTemplate", which knew both what frames it had and what else to draw.  If a PageTemplate has a drawPage method, this is called
when the page starts to drw.

.beginPre Code
class MyPageTemplate(PageTemplate):
    def __init__(self, id):
        myFrame = BasicFrame(inch, inch, 6*inch, 10*inch, id='normal')
        PageTemplate.__init__(self, id, [myFrame])  # note lack of onPage

    def drawPage(self, canvas, doc):
        canvas.saveState()
        canvas.setFont('Times-Roman', 10)
        canvas.drawCentredString(doc.pagesize[0] / 2, 0.75*inch, 'Page %d' % canvas.getPageNumber())
        canvas.restoreState()

.endPre





